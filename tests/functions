#!/bin/bash

info() {
  echo -e "\n\e[1m[INFO] $@\e[0m\n"
}

image_exists() {
  docker inspect $1 &>/dev/null
}

container_exists() {
  image_exists $(cat $cid_file)
}

container_ip() {
  docker inspect --format="{{ .NetworkSettings.IPAddress }}" $(cat $cid_file)
}

container_port() {
  # Expects format 8080:http
  docker inspect --format "{{index .Config.Labels \"io.openshift.expose-services\"}}" $(cat $cid_file) | cut -d: -f1
}

container_logs() {
  docker logs $(cat $cid_file)
}


cleanup_container() {
  info "Cleaning up app container ..."
  if [ -f $cid_file ]; then
    if container_exists; then
      docker stop $(cat $cid_file)
    fi
    rm $cid_file
  fi
}

cleanup_app () {
  info "Cleaning up the test application image"
  if image_exists ${IMAGE_NAME}-testapp; then
    docker rmi -f ${IMAGE_NAME}-testapp
  fi
  if [ -f ${test_dir}/${1}/.git ]; then
    rm -rf ${test_dir}/${1}/.git
  fi
}

check_result() {
  local result="$1"
  if [[ "$result" != "0" ]]; then
    info "TEST FAILED (${result})"
    cleanup_container
    cleanup_app ${app}
    exit $result
  fi
}

wait_for_cid() {
  local max_attempts=10
  local sleep_time=1
  local attempt=1
  local result=1
  info "Waiting for application container to start $CONTAINER_ARGS ..."
  while [ $attempt -le $max_attempts ]; do
    [ -f $cid_file ] && [ -s $cid_file ] && break
    attempt=$(( $attempt + 1 ))
    sleep $sleep_time
  done
}

test_image_version() {
  local run_cmd="$1"
  local expected="$2"
  local cid_file="$3"

  info "Testing the image version"
  out=$(docker exec $(cat ${cid_file}) /bin/bash -c "${run_cmd}" 2>&1)
  if ! echo "${out}" | grep -q "${expected}"; then
    info "ERROR[exec /bin/bash -c "${run_cmd}"] Expected '${expected}', got '${out}'"
    return 1
  fi
  out=$(docker exec $(cat ${cid_file}) /bin/sh -ic "${run_cmd}" 2>&1)
  if ! echo "${out}" | grep -q "${expected}"; then
    info "ERROR[exec /bin/sh -ic "${run_cmd}"] Expected '${expected}', got '${out}'"
    return 1
  fi
}
